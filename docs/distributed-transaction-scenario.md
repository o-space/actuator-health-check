# 分布式事务场景：批量健康检查任务

## 业务场景

### 场景描述

系统需要执行批量健康检查任务，该任务涉及多个资源的更新，必须保证所有资源的一致性：

1. **PostgreSQL**: 保存任务记录到数据库
2. **Redis**: 缓存任务状态，用于快速查询
3. **MongoDB**: 记录详细的执行日志
4. **RabbitMQ**: 发送任务完成通知

### 一致性要求

- **原子性**: 所有资源要么全部成功更新，要么全部回滚
- **一致性**: 所有资源的状态必须保持一致
- **隔离性**: 并发任务之间不能相互干扰
- **持久性**: 一旦提交，所有更改必须持久化

### 失败场景

如果任何一个资源操作失败，所有已执行的操作都必须回滚，确保系统状态一致。

## 实现方案

### 方案一：2PC (Two-Phase Commit) 两阶段提交

#### 工作原理

**阶段一：Prepare（准备阶段）**
- 协调者向所有参与者发送 prepare 请求
- 每个参与者执行验证和准备工作，但不提交
- 参与者返回投票结果（YES/NO）

**阶段二：Commit（提交阶段）**
- 如果所有参与者都投票 YES，协调者发送 commit 请求
- 所有参与者提交更改
- 如果有任何参与者投票 NO，协调者发送 rollback 请求

#### 实现特点

- **PostgreSQL**: 在内存中准备任务对象，commit 时才保存
- **Redis**: 使用临时 key 存储准备状态，commit 时移动到正式 key
- **MongoDB**: 在 prepare 集合中插入文档，commit 时移动到正式集合
- **RabbitMQ**: 准备消息但不发送，commit 时才发送

#### 优点

- 强一致性保证
- 所有参与者要么全部提交，要么全部回滚
- 适合对一致性要求极高的场景

#### 缺点

- 性能开销大（需要两轮通信）
- 阻塞时间长（等待所有参与者响应）
- 单点故障风险（协调者故障会导致阻塞）

### 方案二：TCC (Try-Confirm-Cancel) 补偿模式

#### 工作原理

**Try 阶段（尝试）**
- 所有参与者尝试预留资源
- 执行业务检查，预留必要的资源
- 不提交最终操作

**Confirm 阶段（确认）**
- 如果所有 Try 成功，执行确认操作
- 提交预留的资源，完成最终操作

**Cancel 阶段（取消）**
- 如果任何 Try 失败，执行取消操作
- 释放所有预留的资源

#### 实现特点

- **PostgreSQL**: Try 时创建状态为 "RESERVED" 的记录，Confirm 时改为 "COMPLETED"
- **Redis**: Try 时获取锁并设置 "RESERVED" 状态，Confirm 时改为 "COMPLETED" 并释放锁
- **MongoDB**: Try 时插入 "RESERVED" 状态的文档，Confirm 时更新为 "COMPLETED"
- **RabbitMQ**: Try 时准备消息，Confirm 时发送

#### 优点

- 性能更好（Try 阶段可以并行执行）
- 业务逻辑更灵活（可以自定义 Try/Confirm/Cancel 逻辑）
- 适合长事务场景

#### 缺点

- 需要实现三个操作（Try/Confirm/Cancel）
- 业务代码复杂度较高
- 需要处理幂等性问题

### 方案三：Saga 编排模式

#### 工作原理

**执行阶段**
- 按顺序执行每个步骤的本地事务
- 每个步骤立即提交，不等待其他步骤
- 如果任何步骤失败，立即停止并开始补偿

**补偿阶段**
- 从失败的步骤开始，按逆序执行补偿操作
- 每个步骤的补偿操作撤销该步骤的影响
- 确保最终一致性

#### 实现特点

- **PostgreSQL**: 立即保存任务，补偿时标记为 FAILED
- **Redis**: 立即缓存状态，补偿时删除缓存
- **MongoDB**: 立即插入日志，补偿时删除文档
- **RabbitMQ**: 立即发送消息，补偿时发送取消消息

#### 优点

- 性能最好（每个步骤立即提交，无阻塞）
- 不需要两阶段提交的开销
- 适合长事务和异步场景
- 每个服务独立，降低耦合

#### 缺点

- 需要实现每个步骤的补偿逻辑
- 可能出现部分成功的情况（需要最终一致性）
- 补偿操作可能失败（需要重试机制）

## API 使用示例

### 2PC 模式

```bash
POST /api/batch-health-checks/2pc
Content-Type: application/json

{
  "taskId": "batch-task-001",
  "serviceNames": ["postgres", "redis", "mongodb"]
}
```

### TCC 模式

```bash
POST /api/batch-health-checks/tcc
Content-Type: application/json

{
  "taskId": "batch-task-002",
  "serviceNames": ["postgres", "redis", "mongodb"]
}
```

### Saga 模式

```bash
POST /api/batch-health-checks/saga
Content-Type: application/json

{
  "taskId": "batch-task-003",
  "serviceNames": ["postgres", "redis", "mongodb"]
}
```

## 对比总结

| 特性 | 2PC | TCC | Saga |
|------|-----|-----|------|
| 一致性 | 强一致性 | 最终一致性 | 最终一致性 |
| 性能 | 较慢（两轮通信） | 较快（可并行） | 最快（立即提交） |
| 复杂度 | 中等 | 较高 | 中等 |
| 适用场景 | 短事务、强一致性要求 | 长事务、业务补偿 | 长事务、异步处理 |
| 阻塞风险 | 高 | 低 | 最低 |
| 实现难度 | 中等 | 较高 | 中等 |
| 补偿机制 | 回滚 | 取消 | 补偿事务 |

## 选择建议

- **使用 2PC**: 当需要强一致性，事务时间短，参与者数量少时
- **使用 TCC**: 当可以接受最终一致性，事务时间长，需要业务补偿时
- **使用 Saga**: 当可以接受最终一致性，事务时间长，需要高性能，适合异步处理时
